# 次級繼承人功能設計

## 概述

擴展現有系統以支援「次級繼承人」——被繼承人子女的子女（孫子女）、子女的配偶、曾孫等無限層級的繼承人。採用方案 A：擴展現有 `parentId` 為通用親屬連結。

## 使用場景

- **代位繼承**：子女先於被繼承人死亡，由孫子女代位繼承（民法 1140 條），支援多代代位
- **再轉繼承**：子女後於被繼承人死亡但尚未分割遺產，由其繼承人（配偶、子女）再轉繼承
- **多代深度**：無限層數，理論上支援曾孫、玄孫等
- **配偶參與**：子女的配偶在代位及再轉繼承場景中均可能參與

## 資料模型改動

### parentId 語意擴展

現有 `parentId` 從「僅用於代位/再轉」擴展為「通用家族樹連結」：

- 被繼承人的直系繼承人（配偶、子女、父母等）：`parentId` 為空
- 任何「某人的子女/配偶」：`parentId` 指向那個人的 `id`
- 形成隱式樹：被繼承人（虛擬根）→ 直系繼承人 → 後代 → ...

### Relation 新增值

| 新增值 | 說明 |
|--------|------|
| `'子女之配偶'` | 子女（或孫子女等）的配偶，用於再轉繼承 |

不新增「孫子女」、「曾孫」等 relation——透過 parentId 鏈推導世代。

### 範例

```
被繼承人
├── 配偶 A          { relation: '配偶', parentId: undefined }
├── 子女 B（死亡）   { relation: '子女', parentId: undefined, status: '死亡' }
│   ├── 孫 C（死亡） { relation: '子女', parentId: B.id, status: '代位繼承' }
│   │   └── 曾孫 F  { relation: '子女', parentId: C.id, status: '代位繼承' }
│   ├── 孫 D        { relation: '子女', parentId: B.id, status: '代位繼承' }
│   └── B的配偶 E   { relation: '子女之配偶', parentId: B.id, status: '再轉繼承' }
└── 子女 G          { relation: '子女', parentId: undefined }
```

### 配偶與多次婚姻

- 每個人可有多位配偶，但**現任配偶最多一位**
- 判斷方式：`divorceDate` 有值 → 前配偶（不參與繼承）；無值 → 現任配偶
- 同樣適用於各層級的配偶

## UI 互動設計

整合三種操作方式：

### 右鍵選單（Context Menu）

在樹狀圖節點上右鍵：

- `+ 新增子女`：在此人底下新增子女
- `+ 新增配偶`：新增此人的配偶（無現任配偶時才顯示）
- `✏️ 編輯`：開啟左側編輯面板
- `🗑 刪除`：刪除此人及所有後代

### 節點快捷按鈕

節點底部顯示 `＋` 按鈕，hover 展開為「子女」「配偶」選項。

### 左側編輯面板

選中某人時，編輯面板新增：

```
此人的親屬
  [+ 新增子女]  [+ 新增配偶]
```

### 新增時的自動行為

1. `parentId` = 目標人的 `id`
2. `relation` = `'子女'`（配偶則為 `'子女之配偶'`）
3. `status` 自動推導：
   - 上級死亡且先於被繼承人 → `'代位繼承'`
   - 上級為再轉繼承 → `'再轉繼承'`
   - 否則 → `'一般繼承'`
4. 自動聚焦到新 Person 的編輯面板

## 樹狀圖遞迴渲染

### 佈局規則

- **配偶**：放在該人的左側，水平線連接（所有層級統一）
- **子女**：往下方展開，垂直線連接
- 遞迴建樹，支援無限深度

```
                  配偶 ─── 被繼承人
                      ┌───────┴───────┐
                  子女B(死亡)          子女G
          B配偶E ───┤
                ┌───┴───┐
              孫C(死亡)  孫D
                │
              曾孫F
```

### 建樹演算法

```
buildSubtree(personId, depth) {
  children = persons.filter(p => p.parentId === personId && p.relation !== '子女之配偶')
  spouse = persons.find(p => p.parentId === personId && p.relation === '子女之配偶')

  for each child:
    建立節點（Y = parent.Y + offset）
    遞迴 buildSubtree(child.id, depth + 1)

  if spouse:
    建立配偶節點（X = person.X - offset, Y = person.Y）
}
```

### 節點顯示

- 世代標籤由 parentId 鏈深度推導（子女/孫子女/曾孫等）
- 代位繼承人：虛線邊框
- 再轉繼承人：不同顏色實線

### 邊線規則

- 被繼承人 → 直系繼承人：實線
- 死亡者 → 代位繼承人：虛線
- 再轉者 → 其繼承人：點線

## 繼承計算引擎改動

### 遞迴分配

```
processSlotHolder(holder, slotShare, persons) {
  subHeirs = persons.filter(p => p.parentId === holder.id)

  if 代位繼承:
    repHeirs = subHeirs.filter(s => s.status === '代位繼承')
    each gets slotShare / repHeirs.length
    遞迴處理死亡的 repHeir

  if 再轉繼承:
    按民法規定分配（配偶固定比例 + 子女均分）
    遞迴處理死亡的再轉繼承人

  holder.share = 0
}
```

### 代位繼承遞迴範例

```
子女 B（死亡，份額 1/2）
├── 孫 C（死亡）→ 1/4
│   └── 曾孫 F → 1/4（繼承 C 的份額）
├── 孫 D（存活）→ 1/4
```

### 再轉繼承遞迴範例

```
子女 B（再轉，份額 1/2）
├── B配偶 E → 1/2 × 1/2 = 1/4
├── B子女 C → 1/2 × 1/4 = 1/8
└── B子女 D → 1/2 × 1/4 = 1/8
```

### determineActiveOrder 改動

判斷某順位是否有活著的繼承人時，遞迴檢查：即使直接子女全部死亡，只要有任何後代存活，該順位仍然有效。

## 驗證規則

| 規則 | 說明 |
|------|------|
| 循環參照檢查 | parentId 鏈不能形成循環 |
| 孤立節點檢查 | parentId 指向的人必須存在（已有） |
| 現任配偶唯一 | 每人最多一位沒有離婚日期的配偶 |
| 代位上級必須死亡 | 代位繼承人的 parentId 指向的人須為死亡/死亡絕嗣 |

## Excel 匯出入

不需要改動格式：
- 扁平 `Person[]` 陣列，`parentId` 已是欄位
- 匯出：每個 Person 一列，parentId 自然有值
- 匯入：讀取 parentId 欄位即建立連結

## 刪除行為（級聯刪除）

1. 遞迴找出所有 parentId 鏈中的後代
2. 確認對話框：「刪除此人將同時刪除其下 N 位繼承人，是否確定？」
3. 確認後一次性移除
